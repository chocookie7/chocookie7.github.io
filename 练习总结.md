## 采用较小的存储代价来换取较高的数据库性能
### 修改表的定义
1. **change**：需要写两次列名，可以修改列名称
2. **modify**：只需要写一次列名，不可以修改列名称 
   
#### 插入多行数据
insert into tablename (表格属性),values(1,1,1,1)(2,2,2,2)·····

### 筛选
1. where 聚合前
2. having 聚合后

### 记录联合
1. union all 直接将结果集和并在一起
2. union 将结果合并然后 进行一次 distinct （去重）

### 数值
1. 自动默认为int(11);
2. 填充符号：zerofill：用0填充剩下的内容
3. 整型都有一个可选属性，无符号，如果某列选择了 `zerofill`属性，会自动设置为无符号
4. 还有一个属性AUTO，需要产生唯一标识符或顺序值的时候，想要使用，需要定义为NOT NULL 并定义为PRIMARY KEY 或者UNIQUE键

### 常见的报错内容
报错内容：ERROR 1136 (21S01): Column count doesn't match value count at row 1
含义：内容被截断

### decimal函数的应用
将字段的精度和标度去掉 decimal则不显示小数点之后的内容
如果有精度会自动四舍五入进行插入

## BIT存放数值
1. BIT(位)存放位字段值
2. BIT(M)存放二进制，如果不邪，则直接视为：1，利用select的时候，显示NULL，
3. 可以用bin(),hex()函数进行读取，bin为二进制读取，hex为十六进制

## 时间类
1. 年月日 date
2. 时间 time
3. 完整 
   1. **datetime**：只会显示本地时区的时间信息，支持时间的范围比较大
   2. **timestamp**：跟时区有关，根据不同的时区进行加减，支持时间的范围比较小
   3. 插入日期的时候会先转换为本地时间

### DDL语句
1. 定义：对数据库内部进行增删

### DML语句
1. 定义：记录的insert、update、delete、select 

### DCL语句
管理系统对象权限使用的语句

### verchar 和 char 的区别
1. char
   1. 固定声明长度
   2. 删除尾部空格
2. VARCHAR 
   1. 长度可变
   2. 保留尾部空格

### binary 和 varbinary的区别
1. 两者都包含二进制字符串
2. binary通常在值的最后填充 '0x00'以达到指定长度的字符

### ENUM 枚举
值的范围需要通过显式指定

### set类型
一次可以选多个多个成员

### json
1. 规范：对于大小写敏感

## 运算符
1. 允许左操作数和右操作数进行比较
2. 特殊的运算符
   1. **等于 =**  
     * NULL用`<=>`来进行比较，只有操作数可以用`=`;
     * 1=正确，0=错误
   2. 指定范围 Between
     * 格式： a between min AND max;
   3. 指定集合 in
   4. 通配符匹配 Like
3. 常用运算符
   1. 与：两个不同的数的二进制代码相同的地方才是1 然后输出结果转换为十六进制
   2. 或
   3. 异或 |
   4. 取反 ~
   5. 右移 >>
   6. 左移 <<

### 特殊函数
1. concat： 将两个参数连接成一个字符串
   * 语法： concat('', '', '');
   * 注意：与NULL连接的时候字符串内容都为NULL
2. 大小写
   * LOWER(str)  全部转换为小写
   * UPPER(str)  全部转换为大写
3. 左右分支
   * LEFT(str,x) 返回最左边的第x个字符
   * RIGHT(str,x)   返回最右边第X个字符
   * LPAD(str,n,pad)   

# 实战
## 左连接是什么

## 通过查询已有条件来查询不存在的编号

## 部分内容直接输出，部分内容变换后输出，面对这种情况用union
1. union也有区别
   * union 会自动压缩多个结果集合中的重复结果
   * union all 则将所有的结果全部显示出来，不管是不是重复。

## if语句 两者类型转换，eg：性别转换
1. **IF(expr1,expr2,expr3);** 输入 expr1，if相等 true 输出expr2， 否则false 输出expr3
   * 类似三目运算
2. **IFNULL(expr1,expr2)** 判空
3. **IF ELSE** 可以用AND、OR、NOT组合替代
   ```
   if 条件 then
      内容
   else 
      内容
   end if;
   ```

## 关系模型常用 二维表格 表示实体集，用关键码表示实体间联系的数据模型

## 数据库 ACCESS

### 对象类型
**数据来源基础**
* 表——数据库的基本对象
* 查询——可以按照索引查找需要的记录
**显示和打印**
* 窗体——
* 报表——
**控制**
* 宏——
* 模块——


## 数据库 SQL sever
1. 全局临时表的名称以两个数字符号 "##"打头


## UNION() / UNION ALL()
区别：只**使用UNION**操作符的时候，会列出**不重复**的值

## 事务获得排他锁，代表事务占据主导 可读可写；共享锁只可读

## 规定
1. 修改一个表中的字段名后，不可以在同一个批处理中引用这个新字段

## 对于view update受限的原因
1. 初始View定义的Select语句里如果包含了GROUP BY,DISTINCT,LIMIT或HAVING等命令时
2. 如果视图里数据来自多张字表时

## E－R 图产生于概念设计阶段

## 信息来源于数据  通过对数据的分析 提取了信息   

## 不同名称间的差异

### 第一组
元组
行
记录
属性

### 第二组
DCL
DDL
DML
DQL

### 第三组
字段
数据访问页
记录
储存格
工作表

## 自然连接时，要求R和S含有一个或多个共有的 属性

## DQL、DML 完成对数据库数据的查询与更新。

## 事务原子性——事务中包括的所有操作要么都做，要么都不做

## 下列数据库备份类型中，仅记录自最近一次完整数据库备份以后发生改变的数据的是（差异数据库备份）

## 数据库恢复的基础是利用转储的冗余数据。这些转储的冗余数据是指(日志文件、数据库后备副本)

## having的语法规范描述
having子句必须于group by 子句同时使用，不能单独使用
having子句即可包含聚合函数作用的字段也可包括普通的标量字段
解释：实施上所有的where子句都可以用having代替 

## where和having的区别：
where子句是过滤行；having子句是过滤分组
where在数据分组之前使用，having在数据分组之后使用，可以同时使用

D：使用having子句的作用是限定分组条件 (错误的)
原因：group by 子句是限定分组条件的，**having是过滤分组的**

F：如果select语句中没有聚合函数的使用，就不能使用having子句 (错误的)
原因：

## 查找 非空 的数据项
1. 在mysql中 **不能使用 = NULL 或 != NULL**等比较运算符，因为**null不能被比较**
2. **!=运算符通常后面跟数字**


## BCNF
选D。 超键(super key)：在关系中能唯一标识元组的属性集称为关系模式的超键 候选键(candidate key)：不含有多余属性的超键称为候选键。也就是关系中的一个属性组，其值能唯一标识一个元组。若从属性组中去掉任何一个属性，它就不具有这一性质了，这样的属性组称作候选键。 主属性：任何一个候选键中的属性称作主属性。（请记住这个概念） 主键(primary key)：用户从一个关系的多个候选键中，选定一个作为主键。 函数依赖：一个或者一组属性的值可以决定其他属性的值。候选键都可以做到。 如果非主属性B函数依赖于构成某个候选键的一组主属性A，而且A的任何一个真子集不能被B函数依赖，则称B完全函数依赖于A； 反之，若B函数能依赖于A的真子集，则称B部分函数依赖于A。 图中关系R，零件号可以唯一确定它的单价，因此存在函数依赖 零件号 -> 单价。而不存在 单价-> 零件号。 满足BCNF条件： 1 所有非主属性对每一个候选键都是完全函数依赖； 2 所有的主属性对每一个不包含它的候选键，也是完全函数依赖； 3 没有任何属性完全函数依赖于非候选键的任何一组属性。 因此选D。 各种范式的关系：

## 数据库索引

1. 针对某些字段建立索引，**不一定**能有效的**减少**相关数据库表的**磁盘空间占用**
   原因：索引需要额外的磁盘空间，为一索引页，包含着索引记录，每条索引记录包含键值和逻辑指针
   
2. 针对某些字段建立索引，**不一定**能有效的**提升**相关字段的**读与写的效率；**
   
3. 常见数据库管理系统，可能使用hash表来存储索引；
   原因：**B-Tree是最常用的索引**；

4. **数据库索引的存在，可能导致相关字段删除的效率降低；**
   原因：增加了动态维护的成本

## 数据库范式的说明
1. 关系型数据库设计必须符合第一范式，在这种范式下一个数据列只能有一个值
2. 数据库设计范式的引入，**不一定提高**了数据库**访问的效率**

## SQL 语言具有两种使用方式，分别称为交互式SQL和嵌入式 SQL

## 分组排序函数ROW_NUMBER() OVER()
格式：row_number() over(partition by 分组列 order by 排序列 desc)
*在使用 row_number() over()函数时候，over()里头的分组以及排序的执行晚于 where 、group by、  order by 的执行。*

## 截至日期 to_date('2019-07-27','yyyy-mm-dd')-30) 
